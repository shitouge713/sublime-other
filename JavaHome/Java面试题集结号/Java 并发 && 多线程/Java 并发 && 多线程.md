### Java 并发 && 多线程
1. synchronized 的实现原理以及锁优化？
2. ThreadLocal原理，使用注意点，应用场景有哪些？
3. synchronized和ReentrantLock的区别？
4. 说说CountDownLatch与CyclicBarrier 区别
5. Fork/Join框架的理解
6.  为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
7. Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？volatile 的实现原理
8. CAS？CAS 有什么缺陷，如何解决？
9. 如何检测死锁？怎么预防死锁？死锁四个必要条件
10. 如果线程过多,会怎样?
11. 说说 Semaphore原理？
12. AQS组件，实现原理
13. 假设有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
14. LockSupport作用是？
15. Condition接口及其实现原理
16. 说说并发与并行的区别?
17. 为什么要用线程池？Java的线程池内部机制，参数作用，几种工作阻塞队列，线程池类型以及使用场景
18. 如何保证多线程下 i++ 结果正确？
19. 10 个线程和2个线程的同步代码，哪个更容易写？
20. 什么是多线程环境下的伪共享（false sharing）？
21. 线程池如何调优，最大数目如何确认？
22. Java 内存模型？
23. 怎么实现所有线程在等待某个事件的发生才会去执行？
24. 说一下 Runnable和 Callable有什么区别？
25. 用Java编程一个会导致死锁的程序，你将怎么解决？
26. 线程的生命周期，线程的几种状态。
27. ReentrantLock实现原理
28. java并发包concurrent及常用的类
29. wait(),notify()和suspend(),resume()之间的区别
30. FutureTask是什么？
31. 一个线程如果出现了运行时异常会怎么样
32. 生产者消费者模型的作用是什么
33. ReadWriteLock是什么
34. Java中用到的线程调度算法是什么？
35. 线程池中的阻塞队列如果满了怎么办？
36. 线程池中 submit()和 execute()方法有什么区别？
37. 介绍一下 AtomicInteger 类的原理？
38. 多线程锁的升级原理是什么？
39. 指令重排序，内存栅栏等？
40. Java 内存模型 happens-before原则
41. 公平锁/非公平锁
42. 可重入锁
43. 独享锁、共享锁
44. 偏向锁/轻量级锁/重量级锁
45. 如何保证内存可见性
46. 非核心线程延迟死亡，如何实现？
47. ConcurrentHashMap读操作为什么不需要加锁？
48. ThreadLocal 如何解决 Hash 冲突？
49. ThreadLocal 的内存泄露是怎么回事？
50. 为什么ThreadLocalMap 的 key是弱引用，设计理念是？
51. 同步方法和同步代码块的区别是什么？
52. 在Java中Lock接口比synchronized块的优势是什么？如果你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？
53. 用Java实现阻塞队列。
54. 用Java写代码来解决生产者——消费者问题。
55. 什么是竞争条件？你怎样发现和解决竞争？
56. 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
57. Java中你怎样唤醒一个阻塞的线程？
58. 什么是不可变对象，它对写并发应用有什么帮助？
59. 你在多线程环境中遇到的共同的问题是什么？你是怎么解决它的？
60. Java 中能创建 volatile数组吗
61. volatile 能使得一个非原子操作变成原子操作吗
62. 你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？
63. 我们能创建一个包含可变对象的不可变对象吗？
64. 在多线程环境下，SimpleDateFormat是线程安全的吗
65. 为什么Java中 wait 方法需要在 synchronized 的方法中调用？
66. BlockingQueue，CountDownLatch及Semeaphore的使用场景
67. Java中interrupted 和 isInterruptedd方法的区别？
68. 怎么检测一个线程是否持有对象监视器
69. 什么情况会导致线程阻塞
70. 如何在两个线程间共享数据
71. Thread.sleep(1000)的作用是什么？
72. 使用多线程可能带来什么问题
73. 说说线程的生命周期和状态?
74. 什么是上下文切换
75. Java Monitor 的工作机理
76. 按线程池内部机制，当提交新任务时，有哪些异常要考虑。
77. 线程池都有哪几种工作队列？
78. 说说几种常见的线程池及使用场景?
79. 使用无界队列的线程池会导致内存飙升吗？
80. 为什么阿里发布的 Java开发手册中强制线程池不允许使用 Executors 去创建？
81. Future有缺陷嘛？
